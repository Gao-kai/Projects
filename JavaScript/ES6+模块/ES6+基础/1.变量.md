## ES6概述

#### 1.什么是ES6？

ECMAScript是JavaScript的标准，而JavaScript是ECMAScript的实现。

ES6 也叫作ES2015，是ECMA标准的第6版，在2015年正式发布。

最新的版本ECMA2019

#### 2.为什么要学这个ES6呢？

所有的语言在不断的更新迭代

ES6中支持更多的语法，使用起来更加方便，比如箭头函数

增强的工程性，因为js语言不太严谨，在ES6中得到了改善

当前的前端主流框架Vue里面用到了ES6中的大量语法

## ES6新增变量声明方式

#### var声明变量的问题

1. 变量可以被重复声明，很松散
2. 声明后的变量不可控制其值是否可被修改
3. ES5中变量是函数级的作用域，没有块级作用域

#### 什么是块级作用域

说白了就是花括号{}括起来的代码块，比如for循环 if语句或者单独的一个{}

> 注意：闭包这个东西只是JS中的变量没有块级作用域的情况下的一个临时解决方案，ES6中有了块级作用域，最起码在变量这块就不需要闭包了。具体应用就是用let声明的变量在循环中可以防止成为全局变量。

#### 没有块级作用域引起的问题

ES5之前由于for和if中没有块级作用域的概念，所以在很多时候，我们是借助于function函数具有作用域的特点来解决外部变量的问题。这里的函数多数是立即执行函数。

#### let（声明变量）

1. let声明的变量不可以重复声明；

2. let声明的变量其值可以被修改；

3. let声明的变量具有块级作用域；

4. let声明的变量不可以变量提升


> 也就是说一个变量如果用let定义在块级作用域中，该变量只有在块级作用域中可以访问，在外部访问会报错；但是用var定义的变量由于没有块级作用域，所以可以访问的到。

#### const（声明常量）

1. const声明的常量不可以重复声明

2. const声明的常量其值不可被修改，保证数据的安全性

3. const声明的常量具有块级作用域

4. const在声明常量的时候必须赋初始值


> const声明的产量不能重新进行赋值，如果是基本数据类型，不能更改值；如果是复杂数据类型比如对象，虽然不能更改这个对象保存在栈内存中的内存地址，但是可以修改保存在堆内存中的数据，比如给这个变量进行属性的添加和方法的添加。
>
> ```js
> <script>
>     const obj = {
>         name: 'james',
>         age: 36,
>         team: 'heat'
>     }
>     // 不可以让const定义的常量obj指向发生改变
>     // obj = {}
>     //但是可以让const定义的obj中的属性发生改变
>     obj.name = 'lebron';
>     obj.age = 35;
>     obj.team = 'lakers';
> </script>
> ```

## 经典面试题：点击li打印当前li索引号

#### 错误示范：点击每一个li都会输出相同的值

原因：

1.从JS的执行机制来说的话，for循环是同步任务先执行，点击事件是异步任务后执行。for循环执行结束，什么时候结束呢？是当i = lis.length也就是5的时候循环失败才结束循环。

2.就是var声明的变量是全局作用域中的变量（如果script一开始就有window.onload事件的话，那么就是函数级作用域），所以for每一次循环都改变了全局中的这个i变量，最后当循环结束的时候，i就变成了一个固定的5。

3.本质就是for循环中的i是全局变量，事件处理函数引用的是全局变量i，所以当i在每一次循环中改变之后，最后事件处理函数中引用的i就变成了5，这就是var定义的变量没有块级作用域的弊端。

```javascript
<ul>
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
        <li>555</li>
    </ul>
<script>
    var lis = document.querySelectorAll('li')
	for (var i = 0; i < lis.length; i++) {
	lis[i].addEventListener('click', function () {
                console.log(i);
            })
        }
	}
</script>
```

#### 解决方案1：立即执行函数中的函数访问其局部变量j产生闭包解决

原理就是通过for循环生成了5个不同的立即执行函数，每个立即执行函数中的变量i都是独立且不同的。等于是给每一个i人为的创**造了一个函数局部作用域，函数中的变量是局部变量所以不会在全局上被修改。**

本质就是通过在立即执行函数中的变量j是具有函数级作用域的，所以外部全局变量i的循环和改变是不会影响到函数作用域中变量的值。

```javascript
 <script>
     var lis = document.querySelectorAll('li');
	for (var i = 0; i < lis.length; i++) {
        (function (j) {
            lis[j].addEventListener('click', function () {
                //事件函数访问了立即执行函数的j局部变量 产生了闭包
                alert(j)
            })
        })(i);
    }
</script> 
```

#### 解决方案2：将for循环中的变量用let声明

原理：let声明的变量i具有自己独立的块级作用域，**每次循环都会产生一个块级作用域**，**每个块级作用域中的变量都是不同的**，是比闭包更为优雅的解决方式。

因为for循环中的let i=0这句话是定义在for循环内部的，而let定义的变量i是有自己块级作用域的

```javascript
<script>
    var lis = document.querySelectorAll('li')
	for (let i = 0; i < lis.length; i++) {
        	console.log(i);
    })
}
</script>
```

## ES6解构赋值（变量赋值新方法）

#### 注意事项

结构和赋值必须得同时进行不可以分开

等号右侧必须是一个对象或者数组，不能是{1，2}这种既不是对象也不是数组的 会报错

等号左右两侧必须匹配成功才可以成功解构赋值

#### 解构赋值（★★★）

解构：分解数据结构

赋值：为变量赋值

> ES6中允许我们按照一一对应的方式从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构。
>
> 解构赋值最大的优点是可以方便的从数组和对象中提取值
>

#### 数组解构

数组解构允许我们按照一一对应的关系从数组中提取值，并将值赋给变量。如果变量没有对应的值，那么就是undefined。

let newArr = 

【a，b，c】代表数组的解构 在等号左边 不是代表数组

```javascript
 let [a, b, c] = [1, 2, 3];
 console.log(a)//1
 console.log(b)//2
 console.log(c)//3
//如果解构不成功，变量的值为undefined
```

#### 对象解构

**对象解构实际上是属性匹配，变量的名字匹配对象中属性的名字，如果匹配的上就将对象的属性值赋值给变量。**

{ name, age }实际上代表的是对象解构，其name值和对象Person中的name属性相匹配的时候，对象就把name属性的值赋值给name变量，依次类推这就是对象的解构。

```javascript
 let person = { name: 'zhangsan', age: 20 }; 
1.只写匹配的属性名，属性名name才是赋值的变量
 let { name, age } = person;
 console.log(name); // 'zhangsan' 
 console.log(age); // 20
2.写对应属性的属性名和属性值，属性值nyName才是真正的赋值的变量
 let {name: myName, age: myAge} = person; // myName myAge 属于别名
 console.log(myName); // 'zhangsan' 
 console.log(myAge); // 20
```

#### 小结

- 解构赋值就是把数据结构分解，然后给变量进行赋值
- 如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined
- 数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开
- 利用解构赋值能够让我们方便的去取对象中的属性跟方法