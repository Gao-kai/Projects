本周学习目标（P89-P109）
2021/04/08--- 2021/04/11
+ 彻底搞懂JS中变量提升、作用域和闭包的概念
+ 闭包作为面试必考题，要搞懂它是什么？怎么用？为什么有闭包？有什么用？
+ 大量看这部分的面试题，还有之前渡一的笔记
+ 拉勾教育 05章 JS闭包难点解析
+ 李兵浏览器专栏 浏览器中的JavaScript执行机制 (5讲)

-----------------------------------------------------------------------------------------
### 作用域的概念
浏览器引擎为了能让JS代码从上而下执行，首先会从当前内存中开辟一块栈内存空间当做JS代码执行的环境，栈内存有以下两个作用：
1.栈内存为JS代码自上而下执行提供了环境
2.栈内存用于存储代码执行时声明的变量和基本数据类型的值
而一般情况下，我们把栈内存也就是JS代码执行的环境称为作用域，或者叫做执行上下文[context]。
ES5中的作用域有全局作用域和函数作用域；ES6新增了块级作用域。
全局作用域：浏览器引擎在一开始执行JS代码的时候创建的栈内存空间。
### JS的变量提升机制

1.变量提升机制
当浏览器开辟出供代码执行的栈内存之后，JS代码并不会立马自上而下执行。而是先把当前作用域中所有var声明的变量以及function声明的函数进行提前的声明和定义，这种机制就做JS执行的变量提升机制，在变量提升之后代码才开始真正的自上而下执行。

2.变量提升注意点
+ var声明的变量只是提前声明(decalar)，默认值为undefined，并不会给变量赋值
  var a = 1;   var a声明变量; a = 1;给变量赋值
  
+ function声明的函数，不仅会进行提前声明，而且还会定义(defined),定义其实就是赋值，本质就是让该变量和某个值进行关联。因为JS中变量赋值并不是真正的赋值，而是一种变量和值产生关联的过程。

+ 只有function声明的函数才会被变量提升（声明且赋值），而var a = function (){};这样的函数表达式会被当作var声明的变量只进行提前声明，并不会进行定义也就是变量赋值的过程。
```
sum(10,20);
var sum = function (n,m){
	return n+m;
}
以上代码执行会报错：Uncaught TypeError：sum is not a function  sum变量不是一个函数
因为只把var声明的变量提升到了顶部，并没有定义也就是默认值undefined
```
真实项目中这种函数表达式创建函数的方法最常用，因为这种方法可以避免在函数定义之前执行函数而不报错，ES6中的箭头函数的创建方法也是参考了这种函数表达式的方式。
let fn = (n,m)=>n+m;

### 变量提升阶段var和let声明变量的区别
var声明的变量存在变量提升机制，let/const声明的变量不存在变量提升。
而实际情况下let和const这种声明变量的方式才是合理的。

``` 案例一
console.log(a);
let a = 12;
a = 128;
console.log(a);
第一行代码引用错误：Uncaught ReferenceError: Cannot access 'a' before initialization
```
由于let声明的变量不能在预编译阶段进行变量提升，所以上述代码会报错，没有输出结果。
只要有一行JS代码报错，那么下面的代码都不会被执行。


### let/const和var的区别（五点）
+ var声明的变量存在变量提升机制，let/const声明的变量不存在变量提升，但是在词法解析阶段还是可以检测到某个变量是否为私有变量。（知道某个同学在教室和把某个同学喊道讲台上）

+ 在词法检测阶段，var声明的变量可以被重复声明，而let/const声明的变量如果被重复声明那么在词法检测阶段就会出现语法错误从而导致代码一行都不执行，const声明的常量甚至不可以重新赋值

+ var声明的变量没有块级作用域，let和const声明的变量具有块级作用域

+ var声明的全局变量会挂载到全局window对象上当作属性，而let和const声明的变量不会被挂载到window对象上。

+ var声明的变量不存在暂时性死区，而let和const声明的变量由于存在暂时性死区，在声明之前访问变量或者对变量赋值都会报引用错误ReferenceError

### 全局作用域下声明变量带var和不带var的操作
在全局作用域下的区别：
var a = 10; 
1.在全局作用域下创建一个全局变量a
2.在全局window对象上添加一个属性a


a = 10;
本质是在window全局对象上添加了一个属性a，属性值为10。也就是window.a = 10，a不是变量而是对象的属性。

### var和let重复声明变量的区别
在相同作用域中，用var/function重复声明变量不会报错，在声明第一次之后再遇到就不再重复声明了。

而用let/const重复声明变量会报语法错误，浏览器会校验当前作用域中是否已经存在该变量，如果已经存在，则再次基于let重新声明该变量会报错。
Uncaught SyntaxError: Identifier 'a' has already been declared
报的是语法错误，在词法检测阶段就被发现的语法错误。
```
var a = 12;
var a = 13;
console.log(a); 输出a为13
```

```
let a = 12;
let a = 13;
console.log(a);报错：Uncaught SyntaxError: Identifier 'a' has already been declared

```

### 词法检测阶段
案例二：
按照原理来说JS代码是自上而下执行的，再执行之前在当前作用域进行变量提升。但是let声明的变量并不会变量提升，所以这里应该是按照顺序依次输出1，10.然后到下一行a变量基于let关键字被重复声明了，所以应该报错。也就是顺序为1，10，报错。

但是在控制台打印的结果是不输出任何内容，直接报语法错误:Uncaught SyntaxError: Identifier 'a' has already been declared（很少见的语法报错类型之一）
```
console.log(1);
let a = 10;
console.log(a);
let a = 15;
console.log(a);
```

原因：在JS代码执行之前也就是预编译阶段，除了要进行变量提升的操作，还有很多其他的操作。
其中有一个操作就叫做词法解析或者词法检测。
词法检测：在代码预编译阶段，浏览器引擎会检测当前即将要执行的代码是否出现明显的语法错误，如果出现语法错误，那么代码将不会被执行，也就代表着连第一行代码都不会被执行。

注意：只有在词法检测中出现语法错误[Uncaught SyntaxError]，才会一行都不执行代码；而如果在执行过程中出现其他错误，那么错误语句之前的代码是正常执行，之后的代码就不会被执行。

语法错误SyntaxError：某个事情W3C规定了不能干你干了。比如不能使用let重复声明变量，你非要重复声明了,那么就会在词法检测的时候检测出语法错误并报错。

其他错误：你写了某行代码并不会按照你预期的去走。比如let声明的变量不会被变量提升，这意味着你用let声明变量可以，但是在声明变量之前去访问，你以为会访问的到但是并不会，此时就会报其他错误。


所以上述的案例中，其实第一行console.log(1)代码就不会执行了，直接报错。

案例三：
下面代码的输出结果，按照上面的词法检测阶段之后，应该直接报错，一行都不会打印。
但是这里会先输出1，然后报引用错误：Uncaught ReferenceError: a is not defined

```
console.log(1);
console.log(a);
let a = 12;
```

案例四：
let关键字不可重复声明变量指的并不仅仅是两个let声明同一个变量。而是指只要在当前作用域中不管什么方法而存在的某个变量，该变量在当前作用域中被let关键字又进行了声明，那么此时在词法检测阶段会报语法错误，也就是代码根本不会开始执行，在词法解析阶段就报错了。

```
console.log(a);
var a = 15;
let a = 10;
console.log(a);
// Uncaught SyntaxError: Identifier 'a' has already been declared

```

### var声明的变量存在于window对象上，那么let和const声明的全局变量到底存放在哪里了呢？

在JS中，globalThis对象和window对象是全等的，这两个都被当做全局顶级对象而存在。
在浏览器环境下，访问globalThis对象打印的是window对象
在Node.js环境下，访问globalThis打印的是global对象，主要有以下属性和方法：
```js
Object [global] {
  global: [Circular *1],
  clearInterval: [Function: clearInterval],
  clearTimeout: [Function: clearTimeout],
  setInterval: [Function: setInterval],
  setTimeout: [Function: setTimeout] {
    [Symbol(nodejs.util.promisify.custom)]: [Function (anonymous)]
  },
  queueMicrotask: [Function: queueMicrotask],
  clearImmediate: [Function: clearImmediate],
  setImmediate: [Function: setImmediate] {
    [Symbol(nodejs.util.promisify.custom)]: [Function (anonymous)]
  }
```

方法一：通过debugger命令打开浏览器调试，查看Scope项
暂且不说node环境，在浏览器环境下，如果用let和const声明的变量，在window对象上是访问不到的，如果通过debugger打开浏览器的调试控制台，可以看出let和const声明的变量都是存在于Scope作用域下的Script作用域中，而不是Global作用域。而通过var声明的变量会存在于Global作用域中。
```js
<script type="text/javascript">
	const b = 200;
</script>
<script type="text/javascript">
	let a = 100;
	var c = 300;
	function demo (){};
	console.log([demo]);
	debugger
</script>
```

方法二：通过console.dir(demo)打印全局函数demo，查看函数的[[Scopes]]项
同样的，也可以声明一个全局函数demo，将这个函数demo通过dir或者直接放在一个数组中打印出来，可以看到函数demo有一个属性[[Scopes]]，该属性是一个程序内部的属性，开发者是无论如何都访问不到的，虽然访问不到但是可以看，该属性是一个类似于数组的结构，有两项组成。第一项为Script，它的值是一个对象，该对象中就包含了let和const声明的所有变量。第二项是Global，它其实就是window对象，通过var声明的变量会存在于这个作用域内。
```js
<script type="text/javascript">
	const b = 200;
</script>
<script type="text/javascript">
	let a = 100;
	var c = 300;
	function demo (){};
	console.dir(demo);
</script>
```

### JS代码执行的大致顺序
1.开辟栈内存形成代码执行的作用域(执行上下文)
2.词法检测(预编译阶段)
3.变量提升（预编译阶段）
4.代码自身而下执行

### JS中没有函数的重载(重复进行函数声明） 
在变量提升阶段,函数声明fn和var声明的变量fn都会被提升
var声明的变量fn，只进行声明，未进行赋值
function声明的变量fn，既会声明变量也会赋值

如果一个作用域中的多个函数声明的变量相等，那么只会进行一次声明，但是会进行多次赋值。

变量区域    值区域         堆内存
 fn          AAA01     "console.log(1);"
             AAA02     "console.log(2);"
             AAA03     "console.log(4);"
>>>          AAA04-----"console.log(5);"
			 
经过词法解析和变量提升之后，变量fn最终指向的是内存地址为AAA04的堆内存

在真正开始代码执行的时候，当执行到function fn(){console.log(1);}这一行的时候，由于function声明的变量fn在变量提升阶段已经被声明且赋值了，那么这一行代码不会再被执行直接跳过。此时fn变量还是指向AAA04-----"console.log(5);"

只有当代码执行到var fn = function(){console.log(3);}的时候，因为变量提升阶段只进行了var fn；也就是变量的声明。并没有进行赋值，所以这一行代码执行的意义在于给变量fn重新赋值，也就是重新开辟一个堆内存，并将fn指向该堆内存。

变量区域    值区域         堆内存
 fn          AAA01     "console.log(1);"
             AAA02     "console.log(2);"
             AAA03     "console.log(4);"
			 AAA04-----"console.log(5);"
>>>		     AAA05-----"console.log(3);"
 
之后的代码执行同上，已经再变量提升阶段被声明且赋值的变量，JS在真正执行代码的时候不会再进行一次赋值而是直接跳过；而只进行了变量声明并没有赋值的变量,JS在执行代码的时候还是会进行变量的赋值操作。
 
 
如果变量和函数声明的变量名一致，那么顺序如何计算？
顺序还是自上而下依次来提升，重点有3点：
1.function声明的变量不仅会进行变量声明，而且会完成赋值操作
2.function声明的变量赋值的值类型是引用类型，是存储于堆内存中的
3.一旦某个变量在变量提升阶段已经完成了声明或赋值，那么在JS代码真正的自上而下执行到该变量声明或赋值的地方，为了提高性能，浏览器会直接略过已经完成了声明或赋值的操作，直接执行下一行代码。

案例四：
```
fn();
function fn(){console.log(1);}
fn();
function fn(){console.log(2);}
fn();
var fn = function(){console.log(3);}
fn();
function fn(){console.log(4);}
fn();
function fn(){console.log(5);}
fn();

输出的结果依次是5，5，5   3，3，3

```


### 变量提升中关于判断条件的处理
1.在条件语句中使用var声明变量
重点理解：不管条件是否成立，都会进行变量提升。只有代码真正的自上而下执行的时候才会走条件判断，但是在执行之前会先经过词法检测和变量提升阶段。
```
console.log(a);   undefined
if(!('a' in window)){
	var a = 13;
}
console.log(a);   undefined
```



在上面的变量提升阶段，var a = 13;中的a变量会被提前声明，在全局作用域下一个var声明的变量被提升之后，至少有两个作用：
1.在全局作用域中声明了一个变量a，并赋值为undefined
2.在全局window对象上添加了一个属性'a'，属性值为undefined

所以经过变量提升阶段之后，第一个打印a的结果是undefiend;然后判断属性'a'是否属于window为true取反为false，那么条件不满足，进入不到给a = 13赋值的条件语句中去，所以第二个a打印的结果还是undefined。

2.在条件语句中使用function声明函数
在全局作用域下使用function声明的函数在变量提升阶段既会被声明又会被赋值；但是在新版本的浏览器中，如果一个function声明的函数变量存在与条件语句中，那么只会发生函数的声明而不会被赋值，这是为了向ES6严谨的语法规范。而在老版本浏览器中，条件中的函数既会被声明也会被赋值。
>>> 案例1
```
demo();
if('demo' in window){
	function demo(){
		console.log(666);
	}
}
demo();
```
在上述的代码中，变量demo会进行变量提升，但是由于其处于if条件语句中，那么只会进行变量声明，也就是demo的值为undefined。
当正式执行代码的时候，demo()代表函数被调用，此时demo的值为undefined，那么程序就会报错，报错信息为Uncaught TypeError: demo is not a function

>>> 案例2
```
console.log(demo)
if('demo' in window){
	demo()
	function demo(){
		console.log(666);
	}
}
demo();
```
1.根据前面说的函数声明在条件语句中的提升机制:第一个demo打印的结果是undefined

2.使用function声明的函数在全局作用域下被声明，同时也等于在window的全局对象上添加了对应的属性，这一点和var声明的变量是类似的。所以条件是成立的，此时进入到条件语句中。

3.在进入到条件语句之后，浏览器会把条件语句当做一个块级作用域，首先会完成对于demo的赋值；然后再自上而下执行代码，所以条件语句中的demo()函数执行并不会报错，而是打印666。这是因为在代码执行之前已经在当前作用域中完成了对于demo的赋值

4.最后一个demo()函数执行同样会打印666



### 立即执行函数的几种执行方法
(function(){...函数体})(); 执行函数，不对返回结果做任何处理
(function(){...函数体}()); 执行函数，不对返回结果做任何处理

+ 立即执行函数前面加的+-!~符号以及（）等符号都有一个共同的目的，那就是让匿名函数立即执行并且符合JS中函数执行的语法规范。因为直接写function(){}();程序会报错。这里只是让函数立即执行起来。

+ 同时+-！~这四个符号置于立即执行函数之前，除了会起到立即执行函数的作用，还会对函数的返回值进行不同的操作，操作后的返回值才是函数真正执行的结果。函数如果本来没有返回值那么默认等于undefined。
+ 无论是+-！~还是小括号(),之所以能让原本不符合语法规范的函数可以执行，原因就是在内部会将一个函数声明语句变为一个函数表达式，然后再去执行这个表达式



+function(){...函数体}();  对函数的返回结果先转化为数字类型，如果是有效数字进行一元正负数学运算；如果不是直接返回NaN

-function(){...函数体}(); 同上，也是对函数的返回结果进行数学运算。

!function(){...函数体}(); 对函数的返回结果进行取反

~function(){...函数体}(); 对函数的返回结果进行按位取反 
// 所有正整数的按位取反是其本身+1的负数,
// 所有负整数的按位取反是其本身+1的绝对值,
// 零的按位取反是 -1
按位取反也会对返回值进行强制转换，将字符串5转化为数字5，然后再按位取反
其他非数字或不能转化为数字类型的返回值，统一当做0处理

### 立即执行函数不进行变量提升

>>> 案例：求以下代码执行的结果
```javascript

f = function(){return true;}
g = function(){return false;}

~function(){
	if(g() && [] == ![]){
		f = function(){return false;}
		function g(){return true;}
	}
}();

console.log(f());
console.log(g());

执行结果：Uncaught TypeError:g is not a function
```
1.变量提升的前提是在全局作用域下用var和function声明的变量，不包括函数私有作用域
2.立即执行函数前加~代表函数的立即执行并将函数的返回值按位取反，并且立即执行函数不存在变量提升
3.在全局作用域中不加var声明一个变量就等于在window全局对象上添加了一个同名属性
4.立即执行函数在执行时会形成一个函数私有作用域，在作用域中代码执行之前也会先进行变量提升。
5.如果function声明的函数存在于条件判断中那么在变量提升阶段只会声明不会赋值；如果条件判断成立，进入到块级作用域中第一件事就是给function声明的函数赋值；如果条件不成立那么就直接跳过，此时function声明的函数仅仅被声明但是未定义。

所以以上代码前两句的意思是：
window.f = function(){return true;}
window.g = function(){return false;}

然后接下来执行立即执行函数,在函数作用域中先进行变量提升，此时function g(){return true;}被提升，但是由于处于条件语句中所以只声明不赋值，那么g的值为undefined。

变量提升结束之后开始执行代码，首先判断条件g() && [] == ![]是否成立，由于此时函数作用域下的g的值为undefined，那么程序就会报错，后续的代码也会中止执行。报错信息为：Uncaught TypeError:g is not a function

只需要将g() && [] == ![]修改为window.g() && [] == ![]，那么程序就可以正常执行。

>>> 案例：求以下代码执行的结果
```
var name = 'tom';
(function(){
	// var name; name undefined
	if(typeof name === 'undefined'){
		var name = 'jack';
		console.log('GoodBay' + name);
	}else{
		console.log('hello' + name);
	}
})();
GoodBaytom
对于全局作用域来说，在全局下执行的立即执行函数不会被当做function声明的函数在全局执行栈中进行提升
对于立即执行函数自己的执行作用域来说，它自己执行时形成的私有函数作用域会进行变量提升。

```

### let能解决浏览器的暂时性死区
暂时性死区:其实就是一个浏览器的bug


console.log(a);	Uncaught ReferenceError: a is not defined,
console.log(typeof a); "undefined"		
>> 一个变量既没有被声明,也没有被定义,那么直接访问这个值会报错,只有typeof操作符不会报错,会返回undefined。

console.log(typeof a); 
let a;
报错：Uncaught ReferenceError: Cannot access 'a' before initialization

使用let和const声明的变量，在变量声明之前使用变量就会报错，这是对let声明的变量从声明到赋值这个阶段进行访问那么会形成暂时性死区TDZ，从而报引用错误。
而使用var声明的变量，在变量声明之前使用变量并不会报错，而是会返回变量的初始值undefined。

```
console.log(a); Uncaught ReferenceError: a is not defined
let a = 100;
function fn (){
	/*
	* 在当前函数作用域中进行词法解析的时候浏览器就知道了该作用域中使用let声明了一个a变
	* 量，但是由于let声明的变量具有暂时性死区，所以在此访问a变量发生引用错误：
	* Uncaught ReferenceError: Cannot access 'a' before initialization
	*/
	console.log(a);
	let a = 13;
}
fn();
```

### 函数私有作用域中的变量提升
全局作用域 scope
全局执行上下文 context
全局栈内存 stack


```javascript
console.log(a,b); 
var a = 12,
	b = 12;// 等价于var a = 12;var b = 12;  本质是变量的连续赋值


function fn(){
	console.log(a,b);
	var a = b = 13;// 等价于b = 13;var a = 13; 先给b赋值，然后声明一个变量a并进行赋值
	console.log(a,b);
}
fn();
console.log(a,b);
 
undefined undefined
undefined 12
13 13
12 13
```

### 严格模式和非严格模式下的形参实参映射机制
在非严格模式下,函数中的arguments和形参存在映射关系,那就是一个改另外一个也会跟着改
在严格模式下,函数中的arguments和形参不存在映射关系(use strict)

```
"use strict" 开启严格模式
function x(a,b,c){
	arguments[2] = 10;
	console.log(a);  打印3,改变实参列表形参的值并不会跟着变
}
b(1,2,3);  
```


### JS作用域链查找机制
1.什么是作用域链？


2.什么是作用域链查找机制？
函数在执行时会形成一个私有的函数作用域，在函数作用域中访问一个变量，首选会在当前私有作用域中查找该变量是否被定义，如果有就用当前作用域的，如果没有就向上一级的作用域中查找该变量是否被定义，一直查找到作用域的最顶端window全局作用域，如果还是没有找到那么可能会报错：xxx is not defined。这种一级一级向上查找的机制叫做作用域链查找机制。

函数执行时会形成一个私有作用域，将其私有作用域中的所有私有变量保护起来，所以外部作用域不可以访问函数的私有作用域中变量，这种函数*保护*其私有作用域中变量的机制叫做'闭包'。

3.如何查找上级作用域
作用域链的查找机制的关键在于如何查找上级作用域
1.从函数创建的那一刻开始，该函数的作用域就已经确定。
2.当前函数A是在作用域B中创建的，那么函数A执行时形成的作用域的上一级作用域就永远是作用域B，和函数在哪里执行没关系，只和函数A创建的位置有关。

```javascript
下面例子可见，无论函数x在那个作用域中被执行，函数x的上一级作用域都永远是其创建时的作用域，也就是函数A执行时创建形成的作用域。

var i= 0;
function A(){
	var i =10;
	function x(){
		console.log(i);
	};
	return x;
}
var y = A();
y();  ==>y()代表A函数执行的结果也就是x函数，在全局作用域中被调用

function B(){
	var i =20;
	y();
}
B(); ==> B()代表y(),也就等于函数x执行，此时x函数在B的作用域中被调用

```



### 全局作用域和私有作用域的执行流程
>>> 全局作用域(浏览器打开就产生了全局作用域)
1.只要浏览器打开之后解析JS代码，首先需要创建一个代码执行的环境，全局作用域在此时就被创建出来了，也就是在栈内存中开辟了一块空间用于执行JS代码。

2.然后在栈内存中开辟出变量存储空间和基础数据类型值存储空间

3.变量提升和词法检测阶段(预编译阶段)

4.自上而下正式开始执行JS代码(代码执行阶段)

>>> 函数作用域(只有函数执行才会产生私有作用域)
1.创建函数：开辟堆内存---生成16进制地址----变量和地址进行关联

在任何一个作用域下创建一个函数，仅仅是在当前作用域中开辟一块堆内存，将函数体当做代码字符串存储在该堆内存中，然后让一个变量(函数名)指向该堆内存的内存地址。

2.函数执行：形成函数私有作用域---变量提升&形参赋值---代码执行(遵循作用域链查找机制)

只有当函数被执行的时候，才会形成函数执行的私有作用域。
因为函数执行的本质就是将原先存储在堆内存中的代码字符串放到该函数的私有作用域中，将代码字符串解析成为JS代码自上而下执行。

+ 私有作用域中会在代码执行之前进行形参赋值和变量提升,函数的形参本质是当前私有作用域下的私有变量。
+ 然后代码自上而下执行，在执行的过程中如果遇到一个变量，就遵循作用域链查找机制查找该变量的值。

### 什么是函数的私有变量？
私有变量：在函数私有作用域中的变量存储区域存储的变量叫做私有变量。
1.函数中带var let const function声明的变量
2.函数的形参变量也是私有变量，在函数执行前会完成对于形参变量的赋值，如果没有传递实参那么值为undefined

### 函数形参当做私有变量的特殊情况
前面所学可知:
1.函数在执行时其形参会成为当前私有作用域的私有变量并且在执行前完成形参变量的赋值
2.外部作用域不可访问函数私有作用域中的私有变量,这是函数保护其私有变量的闭包机制决定的
3.私有作用域中查找变量的机制是作用域链一层层向上查找的机制
4.函数执行若干次，就形成多个互不相干的私有作用域。
5.函数在执行时传递的实参一定是一个确定的值，如果fn(foo),那么代表的是将变量foo所存储的那个值当做实参，传递给函数的形参。传递的实参如果是基本类型值是按值传递；如果是引用类型的值等于是将该值在堆内存的引用地址当做值传递给了形参。
6.函数return的一定是一个确定的值，如果return的是一个变量，那么本质是将这个变量存储的值return出去，这个道理和执行函数时传递的实参一定是一个值的道理相同。

注意:
当函数在执行时,函数的形参接收到的实参的值是基本数据类型值,那么是按值操作的,也就是函数内部对于该值的操作互不影响.

但是如果函数的形参接收到的实参的值是引用数据类型值,那么是按地址操作的,本质是将该引用值的堆内存地址传递给了形参。函数内部对于该形参私有变量进行操作,这种变化会同步的影响到外部全局变量。

但是如果该私有变量在函数内部重新指向了另外一个堆内存地址，那么此时私有变量指向了新的内存地址，后续对于该私有变量的操作不会影响到外部的全局变量。

### 函数形参 var function同时声明一个变量a的情况
1.函数内部私有作用域栈执行，先是形参赋值后才是变量提升
2.形参赋值之后，var声明的同名变量a就不再进行提升了，也可以看做无效声明
3.同样，function声明的同名函数变量a也不再提升了，但是赋值必须要进行，所以变量a最终会被赋值为字符串'f a(){}'

```
var a = 100;
funtion fn(a){
	console.log(a);
	var a = 200;
	function  a(){};
}
fn(a);

```




### 一道比较难的闭包面试题
```
var a = 0,
	b = 0;
function A(a){
	A = function(b){
		alert(a + b++);
	}
	alert(a++);
}
A(1); 1
A(2); 4
```

分析流程：(函数重构)
```
GO:{
	a:0,
	b:0,
	A:AF001 => function A(a){...函数体}
	  BF001 => function (b){...函数体} 
}

A(1)执行时的作用域AO:{ AF001
	新参赋值 变量提升
	a: 1,2
	第一次A执行,给全局window上添加了一个A属性,重写了之前的A函数
	也就是将之前指向AF001修改为指向BF001
	所以全局变量A始终指向函数BF001，所以A(1)执行时的作用域不销毁
}

先弹出a的值为1，然后将a的值加1 

A(2)执行时的作用域AO:{ BF001 其上级作用域是去其定义时候的A（1）执行时的作用域，因为只有A（1）执行了才有了重构函数A，才在堆内存中创建了小函数，所以无论它在哪里执行，其上级作用域是创建堆内存的时候就确定的。
	新参赋值 变量提升
	b:2
},
弹出弹框 a + b++ = 2 + 2 = 4

```

