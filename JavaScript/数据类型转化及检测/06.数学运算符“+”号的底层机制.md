## 数学运算符“+”号的底层机制

### 规则1 在js中加法的规则只有两种
1.将数字和数字相加，结果是数字的算数运算
2.将字符串和字符串相加，结果是字符串的拼接
其他所有类型的值在进行+法运算的时候，最后都会转化成为这两种情况进行运算

### 规则2  加法运算会触发三种类型转化
1.将引用值转化为原始值（如果有必要的话）
2.将其他值转化为数字
3.将其他值转化为字符串

### 规则3 其他值转为原始值的底层机制 toPrimitive(value,[Type])
toPrimitive()方法是js引擎内部进行加法隐式转化的底层方法，它接收两个参数，该方法一定会将一个任意类型的值转化为原始值，否则抛出错误。
1.第一个参数value就是需要转化的值
2.第二个可选参数Type的可选值为Number或者String。

如果可选参数的值标志为Number，那么流程如下：
1.如果value自身就是原始值，那么直接返回即可
2.如果value是引用值，那么先调用引用值自身的valueOf()方法，如果返回的值是原始值，那么就返回该原始值（如果valueOf方法没有被重写，那么该方法都是返回引用值自身还是引用值）
3.上一步的返回值还是引用值的话，那么再调用该引用值的toString()方法将value转化为原始值
4.否则，抛出类型错误TypeError异常。

如果可选参数的值被标志为String,那么大致流程同上，只是23步调换顺序，就是先调用toString方法，然后调用valueOf方法。

如果没有声明该可选参数，该可选参数的值有以下规则：
1.如果value是Date日期类型的引用值，该可选参数的值就是String
2.除了Date类型，其他所有类型的value值，可选参数的值都会被标记为Number



## 将“+”法运算应用toPrimitive()方法
没有显式声明可选参数，那么默认采用可选参数为Number的方案及流程
先将+号左右两侧的值运用该方法转化为原始值
如果转化为原始值的过程中，出现了字符串类型的值，那么进行字符串拼接
如果没有出现字符串类型的值，那么都转化为数字类型进行相加

例子1：[]+[]的结果是多少？  => ""
toPrimitive()方法选用Number方法，分别转化原始值
两个空数组分别转化为原始值空串 
发生字符串拼接，结果还是一个空串  ''+'' =>""

例子2：[]+{}的结果为多少?   => "[obejct Object]" 原理同上

例子3:[1,2] + [3,4]的结果为多少？
[1,2] 转化为原始值为'1,2'
[3,4] 转化为原始值为'3,4'
进行字符串的拼接，结果为'1,23,4' 而不是'1,2,3,4'

例子4：怎样执行最后都是引用值，那么抛出类型错误
```
let obj = {
  valueOf: function () {
      console.log('valueOf');
      return {}; // object
  },
  toString: function () {
      console.log('toString');
      return {}; // object
  }
}
console.log(obj + obj);  //valueOf -> toString -> error!
```


### 特殊情况1：引用值在转化时直接将字符串拼接，不等待完全转化为数值后进行计算
例子：[12] + 10的值是多少？
表面看起来，由于[12]是引用值并且出现了+号，那么会将引用值转化为数值类型，也就是[12]转化为数字之后应该是12，然后+10答案应该为22。
其实在数组[12]转化为数值的过程中，由于需要先调用valueof()方法，该方法返回数组本身，还是引用值
然后再调用toString()方法将数组[12]转化为字符串'12'
在转化为字符串12的时候，由于有+号运算符，所以直接进行了字符串的拼接，结果是'1210'。

举一反三：
[]+10  转化过程中直接拼接   '10'
10+[]  转化过程中直接拼接   '10'

### 特殊情况2  当加法运算的第一个操作数是空对象的时候，会出现诡异的情况

#### 1.{}+10的结果是多少？

我们期望+号左右两侧都是一个表达式，但是结果却被解析成为了js的语句。如果避免这种情况：

解析：{}+10在谷歌浏览器的控制台中打印会是数字10。这里不涉及到任何类型转化的规则，就是单纯的js引擎将不加小括号的{}解析成为一个没有加分号的代码块,也可以理解为块级作用域。所以{}+10其实本质是两个语句: {}; +10;真正进行运算的是+10的结果，这里的+号是一个一元正负运算符，它的规则是将加号后面的操作数转化为数字类型。
举一反三：
{}+'demo'  结果是'demo'字符串转数字为NaN
{}+true    结果是1
{}+[]      结果是+[]转数字为0
{}+undefined   结果是NaN
{}+null    结果是0


#### 2.({})+10的结果是多少？
解析：js引擎在解析小括号的时候，会将小括号包裹的内容看做一个表达式，而不会被看做一个单独的代码块。所以这里会涉及到之前的toPrmitive()方法的规则。
（{}）被转化为原始值，采用Number方案结果为'[object Obejct]'
10本来就是原始值，直接返回
操作数存在字符串，直接进行字符串拼接，结果为'[object Obejct]10'

#### 3. {}+{}的结果是多少？重点：不同浏览器结果不同
首先解答这个问题之前，搞明白几个关键点：
1.为什么{}在开头的时候会被解析成为一个代码块?
因为如果左大括号出现在一条语句的开头，则这个左大括号会被解析成一个代码块的开始。核心是左大括号。
2.如何避免这种js引擎的解析机制对我们的影响？
可以采用小括号将需要计算的值包裹起来，比如：
({}) + 10
({} + 10)

一个函数或方法的参数总是会被解析成为一个表达式而不是语句，比如：
console.log({}+10) 的值就会遵循表达式规则转化为'[object Obejct]10'

了解了以上两个点以及之前的知识，在这里{}+{}，第一个{}解析为代码块，+{}才是真正的运算，而+是一元运算符将{}转化成为数字为NaN，这是火狐浏览器中的结果。

而在谷歌浏览器中，{}+{}总是会被解析为"[object Object][object Object]"


### a++和a+=1的区别
```
var a = '10';
a++; 
console.log(a);  值为11,i++是纯粹的数学运算，会将前面的变量的值转化为数值后再进行计算

var a = '10';
a +=1;
console.log(a);   值为'101' 本质是字符串的拼接

```
 ### a++和++a的区别
 a++ 和 ++a都是数学运算中的给自身+1后赋值给自身，唯一的区别是在和其他js表达式在进行计算的时候计算的顺序是先进行运算还是先进行自加，如果没有参与运算，那么写在前后都是一样的。
 
```
var a = 100;
console.log(a++); 100  先进行运算，然后然后再将自身+1
console.log(a);   101

var b = 90;
console.log(++b); 91 先自身加1，然后再进行后续的运算
console.log(b);   91

```