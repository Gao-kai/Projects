
## number数字数据类型详解（2021年3月11日）
### Number()强制转型函数规则
1.转基本类型的值
转字符串
Number('')  转化为0
Number('13.5')  转化为13.5
Number('13.5.0') 转为NaN 只能识别一个小数点 第二个小数点是非有效字符
Number('13.5px') 转为NaN 只要字符串中出现任意一个非数字有效字符就返回NaN
转布尔值
true转化为1 false转化为0
转undefined 结果为NaN
转null 结果为0

2.转引用类型的值
先调用引用值自身得toString()方法转化为字符串；然后将字符串转为数值

转数组
空数组[] 转为0
单值数组[1] 转为1
多值数组[1,2] 转为NaN
原因：空数组调用toString()方法转化为空串'',空串转化为数值为0
	  单值数组[1]调用toString()方法转化为字符串'1'，转化为数值1
	  多值数组[1,2]调用toString()方法转化为字符串'1,2'，由于该字符串中有逗号是非数值字符，所以返回NaN

转对象
任何对象都会被转化为NaN
原因：任何对象调用toString()方法转化为字符串'[object Object]'
字符串'[object Object]'再转化为数值结果就是NaN

转正则和函数
正则 /\d/调用toString()方法转化为字符串'/\d/',有非有效数值，所以返回NaN
函数 function demo(){}调用toString()方法转化为字符串'function demo (){}',有非有效数值，所以返回NaN
### praseInt()和parseFloat()方法 将字符串转化为整数值方法
和Number()方法的区别在于字符串的分析上不同
Number()方法遇到任意一个非数值有效字符就会转化为NaN
praseInt()方法会将一个字符串中的整数部分解析出来
parseFloat()方法会将一个字符串中的浮点数部分解析出来

>> praseInt()和parseFloat()方法的查找机制是基于将字符串转化为数值，如果传入该方法的参数是其他数据类型，那么先要转化为字符串，然后按照其自身的查找有效字符的机制，将字符串转化为数字。

>> 解析规则：会从字符串的最左边开始查找有效数字字符，如果找到数字字符会转化为数字，但是只要遇到一个非有效数字字符，那么就结束查找。其实和Number()的底层机制是完全不一样的。


>>举例
praseInt(undefined) => praseInt('undefined') => NaN
praseInt('') =>NaN 好奇这里不是应该将空串''转化为数字是0么，这是因为praseInt的解析规则是从左到右是否查找到了有效数字，这里的空串中并没有查到有效数字，所以返回NaN。

### praseInt(string,radix) 
1.作用：parseInt函数将其第一个参数转换为一个字符串，对该字符串进行解析，然后返回一个10进制的整数或 NaN。

2.参数string是字符串值，如果该值不是字符串则调用toSting（）方法转为字符串，如果第一个字符不能转换为数字，parseInt会返回 NaN。
参数radix是转化的基底，取值返回为2-36，注意10不是默认值

3.返回值：该方法的返回值一定是数值类型的，就看是有效数值还是NaN
返回值是NaN的情况是，传入的参数string的第一位字符是非有效字符，比如'w12'
传入的参数radix的范围不是2-36之间，即小于2大于36

4.举例：
praseInt(152,5) 将152当做5进制的数转化为10进制的数
问题在于5进制的数逢5进1，这里很明显错误了，直接将1后面的52删除，本质就是
praseInt(1,5) 1乘5的0次方 结果就是10进制的1

parseInt("Hello", 8); // 第一个参数Hello解析为数值的时候变为NaN
parseInt("301", 2);   // 除了“0、1”外，其它数字都不是有效二进制数字



### NaN和isNaN()方法
NaN 意思是not a number 表示非数 属于number数据类型
1.检测一个值是否为NaN？
通过isNaN(value)方法 
该方法接收一个任意类型的值，返回一个布尔值
如果返回true，代表这个值是NaN；如果返回false，代表当前这个值不是NaN
2.isNaN()方法检测的机制或本质
首先判断检测的值是否为数值类型，如果是直接判断，如果不是，会默认将检测的值通过Number转型函数转化为数值类型的值，然后进行判断。

isNaN()底层原理为Number()转型函数；Number()转型函数分为基本和引用，而引用类型转化又基于toString()方法

isNaN(undefined)  返回true 本质是undefined经过Number()转型函数之后会变为NaN
isNaN(null) 返回false 本质是null经过Number()转型函数会变为0,0不等于NaN

isNaN({}) 返回true 本质是引用类型的值经过Number()转型函数之后变为NaN

isNaN([]) 返回false 本质是空数组经过Number()转型函数之后变为0
isNaN([1]) 返回false 本质是单个值的数组经过Number()转型函数变为该值本身也就是1
isNaN([1,2]) 返回true 本质是多个值的数组结果经过Number()转型函数之后变为NaN

3.检测一个值是否为一个有效数字，有且只有一种方法那就是通过isNaN()方法

### Object.is(value1,value2)
Object.is(value1，value2)方法用于判断两个值是否为同一个值
该方法接收两个比较的值，返回一个布尔值。

该方法返回值为true的情况有：
两个值都是undefined
两个值都是null
两个长度和顺序一致的字符串
两个值都是true或者都是flase

一：注意在引用类型的值比较的这块：（本质是判断引用地址是否相等）

1.因为两个对象在内存中的引用地址不同，指向不同的引用地址
var a = { b:1};
var b = { b:1};
console.log(a==b,a===b); 返回false false
console.log(Object.is(a,b)); false

2.引用类型的赋值是将栈内存中的引用地址进行复制，所以两个对象指向同一堆内存
var a = {b:1};
var c = a;
console.log(a==c,a===c); 返回true true
console.log(Object.is(a,c)); true

二：注意在数字类型比较的这块，和以前有很大不同

通过相等符号==或者全等符号===进行判断的时候：
0和+0 -0 三者怎样判断 都是true
NaN由于和任何值进行运算都会返回自身NaN，所以NaN === NaN是false

但是通过Object.is()方法判断的时候
只有+0和+0；-0和-0；0和0；0和+0 这四个是true
两个NaN返回的结果是true
由于0/0返回NaN，所以NaN和0/0判断也返回true

## boolean布尔值类型详解
### 如何将其他数据类型转化为布尔值？
1.调用转型函数Boolean()
`除了0 NaN undefined unll ''这五个值之外 JS中所有的值都是true`
2.逻辑非！
在任意一个值前面加上逻辑非！运算符，等于是隐式的调用了Boolean()函数将该值转化为布尔类型，然后将得到的布尔值取反。
3.逻辑非取反！！
在任意一个值前面加上两个！！，等价于是直接调用了Boolean()函数将该值转化为布尔类型
这种写法和直接调用Boolean函数没有任何区别，只是在写法上比较简便

## String 字符串类型详解
### 什么是字符串
在js中所有用单引号、双引号或者反引号（ES6 模板字符串）包裹起来的都是字符串

### 如何将其他类型的值转化为字符串？
1.调用toString()方法
>> 基本数据类型转字符串
数值类型转字符串，直接转为对应的字符串

注意：1.toString()为什么会报错？
因为数字1后面的点和1被js解析成了一个浮点型数值1.;所以直接这样写是会报错。

注意：undefined和null不可以直接调用toString()方法，只能通过String()方法来转化为字符串
true = > "true"

>> 引用数据类型转字符串
普通对象{} 转字符串 转为"[object Object]"
原因是Object.protoType.toString()方法不是用来将对象转字符串的，是用来检测js中的数据类型的方法之一。

数组转字符串，本质是先去掉数组的中括号，然后将数组中的内容调用toString()方法进行转化
[] 去掉括号为空 调用toString()方法之后转为''
[1] 去掉括号为1 调用toString()方法转为'1'
[1,2] 去掉括号为'1,2',调用toString()方法之后转为'1,2'

**2.使用字符串拼接**
任意数据类型和一个字符串值进行"+"号运算的时候，会进行字符串的拼接操作。

数学运算符号中的加号，不仅有数学运算符号的功能，还有字符串拼接的功能。

数学运算符号(+ - */ %)在和数值进行运算的时候，如果另外一个值不是字符串，那么会将这个值先转化为数值类型，然后再进行运算；如果另外一个值是字符串且运算符号为+号，那么会直接发生字符串的拼接操作。

``注意：在进行数学运算的时候，如果在将某个引用类型的值转化为数值的过程中先转为字符串，然后再将字符串转为数字，这里会在转为字符串的那一刻直接进行字符串的拼接，不会再进行后续的转数值操作了，一定要注意。``

**3.字符串拼接面试题1**

```
let a = 10 + null + true + [] + undefined + '珠峰' + null + [] + 10 + false;
```

都是加号运算符，运算优先级一致，从左向右开始计算
10 + null => 先将null调用Number函数转为数字0 结果为10+0 = 10；
10 + true => 将true转为数字1，结果为10+1 = 11；
11 + [] => 将[]转化为数字的过程中，先调用toString()方法转化为空串"",然后再将空串调用Number()函数转为0；但是这里要注意在转化为空串之后，左右两侧有一个值是字符串且运算符号为+号，所以会直接发生字符串的级联，不会再进行后续的转数值操作，所以结果为 11 + '' = '11'
'11' + undefined => "11undefined"
"11undefined" + '珠峰' => '11undefined珠峰'
"11undefined珠峰" + null = > "11undefined珠峰null"
"11undefined珠峰null" + [] => "11undefined珠峰null" + '' = "11undefined珠峰null"
"11undefined珠峰null" + 10 => "11undefined珠峰null10"
"11undefined珠峰null10" + false => "11undefined珠峰null10false"

>>>>>> 最终结果是"11undefined珠峰null10false"，核心考点在于引用类型转数值类型的时候会先调用toString()方法转为字符串，然后字符串再调用Number()方法转为数值。但是如果转换前后的两个值运算符号中有+号，会直接发生字符串的拼接。

**4.字符串拼接面试题2**
（如果运算的字符串值在前，比如'str' + {} 'str' + []这种）
如果另外一个值是基本数据类型，直接进行字符串的拼接操作
如果另外一个值是引用数据类型，那么会先将引用数据类型值转为字符串值，然后进行拼接

（如果运算的字符串在后，比如{} + 'str' [] + 'str'这种）
如果另外一个值是基本数据类型，直接进行字符串拼接
如果另外一个值是引用数据类型，先将引用数据类型的值基于toPrimitive转化为原始值，然后再进行计算。
```
{} + 'str' 
NaN

[] + 'str'
"str"

'str' + []
"str"

'str' + {}
"str[object Object]"
```

## null和undefined的区别
1.值自身的含义不同
null代表空对象指针，一般都是人为的先赋值为null，然后在后续的程序中再次赋值
undefined代表未定义的值，一般都不是人为手动去赋值的，大部分都是在解析js代码的时候自主为空
2.在js中出现的场景不同
`null出现的场景`
当一个值是在未来会当做对象来存储数据而暂时又不想赋初始值的时候，多数情况下会给这个变量赋一个值为null
null被当做原型链的终端而存在

`undefined出现的场景`
当一个变量在声明之后未赋值的时候，该变量的值是undefined
当一个函数的形参没有接受到值的时候，该形参（变量）的值为undefined
当一个函数没有显式的return值的时候，调用该函数返回的结果是undefined
当访问一个对象上没有的属性的时候，该属性的属性值为undefined
在声明一个数组的时候，如果只给当前数组传入一个数值x，那么代表生成了一个length为x的数组，数组中的每一项值都是undefined
一个即未声明,又未赋值的变量,typeof的结果反而是undefined
已经声明未赋值,typeof的结果还是undefined

`var arr = new Array（10） 生成一个长度为10的数组，数组每一项都是undefined`
var arr = new Array(10,11) 生成一个长度为2的数组，数组为[10,11]
注意：在创建数组的时候new Array（）和Array（）的效果一样 new可以省略

3.数据类型不同
通过typeof来检测数据类型的时候，undefiend返回undefined；null返回object
注意：object操作符返回的值一定是字符串类型的

4.类型转化时不同
Number()转型函数 undefiend返回NaN null返回0
undefiend和null没有toString()方法，只可以调用String()转型函数

## 引用数据类型详解
### object普通对象特点
对象是由0到多组无序的属性名和属性值的键值对构成
>> 到底什么是对象属性？
属性是用来**描述当前对象特征**的，属性名是当前具备这个特征，属性值是对这个特征的描述
property和attribute，前者是对象属性，后者多数为css属性
属性名多叫做键，用key表示
属性值多叫做值，用value表示
所以一组属性名和属性值叫做键值对

>> 对象键值对的增删改查
```
var obj = {
	name:'james',
	age:9
}
```
**查询对象属性 增加属性 修改属性**
一般来说，属性名都是字符串格式的，但是在js中字符串引号可以省略
在JS中的同一个对象中，属性名是不允许重复的，所以对象的增和改是一样的
obj.name  点操作方法
obj['name']  中括号操作法 注意这里的name必须加引号
中括号的好处是可以在括号中写变量，从而读取变量的值。

**删除对象属性**
彻底删除: delete obj.name 或者obj['name']
假删除： obj.name = null;并没有移除该属性，只让该属性的值变为空

>> obj[key] 和 obj['key']的区别
obj[key] 代表先获取变量key存储的值，然后获取obj对象上属性名为该值的属性值，如果没有返回undefined
obj['key'] 代表获取obj对象上属性名为key的属性值

>> 对象的属性名写法
对象的属性名大多数情况下都是字符串格式的，一般情况下属性名在书写的时候不加引号

对象的属性名还有可能是数字格式的，当属性名是数字的时候，获取属性值只能用obj[0]或者obj['0']或者obj["0"]，不能写obj.0 此时会报语法错误Uncaught SyntaxError：Unexpected number

当其他数据类型的值当做对象的属性名时，会先调用toString()方法转化为字符串，将转化后的字符串类型的值当做属性名进行存储。读写的规则都是一致的。

```
声明一个对象字面量的时候，里面的属性名有哪些要求？
var obj = {
	[12]:1000,
	[12,23]:500,
	{a：12}：500，
}
第一个会将【12】转化为字符串12，然后12当做属性名，1000当做属性值

第二个[12,23]会报错，因为,的存在会导致无法识别，Uncaught SyntaxError: Unexpected token ','

第三个对象也会报错：Uncaught SyntaxError: Unexpected token '{'

也就是说在声明一个对象字面量的时候，里面的属性名只能是基本数据类型的值，或者是只有有一个值的数组[100],其他引用类型都会报错。只有一个值的数组会将里面的值转化为字符串之后当做对象的属性。
```

```
如下：往对象obj身上依次添加若干属性（和直接声明对象字面量有区别）
var obj = {};

obj[undefined] = 200;  
obj[null] = 100;
obj[true] = 100;
obj[[]] = 50;
obj[{}] = 200;
obj[0] = 100;

得到的obj对象是
obj = {
	"": 50   空数组被转化为空串
	0: 100   
	[object Object]: 200  空对象被转化为[object Object]
	null: 100
	true: 100
	undefined: 200
}
```

### 数组也是对象（数字当做属性名的特殊对象）
1.为什么对象的属性名除了字符串以外还有数字类型？
原因：由于在js中数组也是对象，当我们定义一个数组的时候，其实也可以说我们定义了一个数组对象。只要是对象就是由键值对组成的。
var arr = [12,23];
这个数组对象在展开以后其实是：
arr = [
	0:12,
	1:23,
	length:2
]

也就是说数组对象的属性名是数字，我们把数字属性名当做当前数组对象的索引。
索引就是数组对象的属性名，必须是数字类型，而且可以递增。
**所以说对象的属性名只能是数字和字符串等基本数据类型的值，不可能是引用数据类型的值**
所以读取数组中值的方法可以是arr[0]或者arr['0']
但是不可以是arr.0 此时会报语法错误 Uncaught SyntaxError：Unexpected number

2.对象的属性名可以是数字类型和字符串类型，那么数组对象中可以出现非数字属性么？

因为数组的本质是对象，所以对象可以添加age当做属性名，那么数组也可以添加非数字类型的值当做属性名。
var arr = {
	0：100,
	1:520,
	age:95,
	length:3
}

注意：直接写var arr = [1,2,age:18] 会报语法错误，因为js中的中括号不支持这种写法
但是可以通过点方法或者中括号方法给arr添加age属性，属性值为18
arr.age = 18;
arr['age'] = 18;
写arr[age] = 18;最终展开后会是"":18;因为不加引号代表age是变量，但是age变量又没有找到，那么等于是将一个空串''当做属性名添加到了数组对象身上。

3.拓展 
只要是对象类型，比如正则对象，函数也是对象等，都可以按照对象这种特性来为自身添加或者删除属性，属性名可以是数字或者字符串，其他类型的值当做属性名会被转化为字符串类型后当进行存储。


## JS中数据类型检测方法(有且只有四种方法)
1.typeof value
typeof 检测出来的结果首先是一个字符串，字符串中包含着数据类型
typeof null =>  "object" 原因在于null代表空对象指针，也就是null没有指向任何堆内存空间。

typeof只能检测基本数据类型，不能正确检测对象。
```
问下面程序的输出结果是多少？ 答案是字符串类型的'3'
var num = parseInt("width:35px"); NaN
if(num == 35){
	alert(1);
}else if(num == NaN){
	alert(2);
}else if(typeof num == 'number'){
	alert(3); 
}else{
	alert4()
}
```
typeof num == 'number' 先进行typeof num运算 然后再进行 == 相等判断
alert（3）alert()方法的返回值一定是字符串类型的值，也就是'3'，如果写3是错误的。
alert（{}）返回字符串类型的值：'[object Object]'

2.instanceOf 用来检测当前实例是否属于某个类
3.Object.prototype.toString.call([value]) 最全面的检测数据类型的方法
4.constructor 基于构造函数检测数据类型（也是基于类的方式）

### 数学运算符号和比较运算符号的隐式转化规则
数学运算符号 + - * / % 这五个数学运算符号，在进行运算的时候，如果遇到非数值的值，会先调用Number（）函数将值转化为数值，然后在进行数学运算。
当运算符号为+号，且运算的时候有一个值是字符串的时候，会发生字符串的拼接，而不会转化为数值后进行运算

大于 小于 这两个比较运算符其实遵循的规则和上面一致，都是需要转为数值之后进行比较
```
{} > 5  浏览器会报错 Uncaught SyntaxError ： Unexpected token >  语法错误：不期望的值> 
({}) > 5 会将对象{}转化为数值NaN,然后比较，得到结果false
```

### 访问对象属性时的几种情况
```
var name = 100;
var obj = {
	name:200,
}
obj.name  200
obj['name'] 200
obj[name]  undefined
```
obj.name 访问的是obj对象身上的name属性的值
obj['name'] 访问的是obj对象身上的name属性的盒子
obj[name] name没有加字符串，那么代表是name变量，而变量在js中是没有实际意义的，它只代表它所存储的那个值。
所以obj[name] name变量存储的值是100，那么就等于访问obj的对象上属性名为100的属性值，obj中并没有此属性100，所以返回undefined

三句话总结：
1.JS中访问对象的属性值只有两种方法，点方法和中括号方法，点方法的局限性在于不可访问属性名为数字的属性值。

2.JS中的属性值大多数情况下都是字符串或者数值，还有一些其他的基本属性类型，或者只有一个值的数组，除此之外没有其他形式。

3.JS中的变量代表的是它所存储的值，它自身并没有任何意义，只是一个存储数据容器。