## JS中的数据类型分类
基本数据类型（7种）
Number
Boolean
String
Null
Undefined
Symbol（ES6新增 代表唯一的值）
如果需要创建一个唯一的且不可修改的值，那么就需要Symbol
const a = Symbol（"demo"）;
BigInt

引用数据类型（6种）
Object 对象 对象又分为以下几种类型
	普通对象 Object
	数组对象 Array
	正则对象 RegExp
	数学对象 Math
	日期对象 Date
	错误对象 Error	
Function 函数 （函数其实也是对象，但是typeof返回的是function）

### 其他类型转number类型
1.什么情况下其他类型会转number类型？

+ isNaN() 方法检测的时候：当检测的值不是数字类型的时候，浏览器会调用Number()方法将被检测的值转化为数值类型，然后再检测是否为有效数字。
+ 基于parseInt/parseFloat/Number等原生方法手动将其他数据类型转化为数值类型
+ 在进行数学运算的时候，比如 + - * / %等数学运算的时候，会将其他数据类型值转化成为数值类型，然后再进行数学运算。注意+号不仅可以进行数学运算，还可以被当做字符串的拼接符号。
注意：i++ 递增或递减运算符，就是单纯的数学运算，已经摒弃了字符串拼接的规则
```
var i = 5;
i = i+1; 输出'51'
i += 1; 输出'51'
i++;  输出数字6
```
+ 在基于"=="比较的时候，有时候也会把其他值转化为数值类型之后再进行比较

2.转化规律（基于浏览器的Number()方法）
+ 字符串转化为数字
空串''转化为0
空格字符串' ' 也转化为0
换行符'\n' 也转化为0
制表符键'\t' 也转化为0
只要遇到一个非有效数字，就返回NaN
+ 布尔值转数字  true 1 false 0
+ undefined转数字  NaN
+ null转数字 0
+ 引用类型值转数字
先调用toString()方法转为字符串，然后将字符串基于Number()转为数字
### 其他类型转字符串类型
1.什么情况下其他数据类型会转化为字符串？
+ 基于alert/confirm/prompt/document.write等方法输出内容的时候，会把输出的值转化为字符串，然后再进行输出。
alert(1) => '1'

+ 在基于"+" 号进行字符串拼接的时候
+ 把引用类型的值转化为数字的时候，首先会被转化为字符串，然后再转化为数字
+ 给对象设置属性名的时候，如果属性名不是字符串，首先会被转化为字符串，然后再当做属性存储到对象中（对象的属性名只能是数值或者字符串）
+ 手动调用toString/String/toFixed/join等方法的时候，也会将值转化为字符串
```
var num = Math.PI;
num.toFixed(2);保留小数点后两位，得到的结果是字符串类型的"3.14"

var arr = [1,2,3,4]
join方法用于将数组中的每一项放入一个字符串，然后通过分隔符号来进行分隔。
arr.join() 将数组中值转化为字符串 得到"1,2,3,4"
arr.join('') 将数组转化为字符串   得到 "1234" 
arr.join("-") 将数组转化为字符串  得到"1-2-3-4"

```

2.转化规律（基于toString()方法进行转化）
除了对象，都是默认的转化方法
普通对象转化为字符串的结果是固定的 => "[object Object]"
函数转为字符串 返回函数代码字符串
空数组[] ''
数组[1] "1"
数组[12,23]  "12,23"




### 其他类型转布尔值类型
1.什么情况下其他值会转化为布尔值？
+ 基于！/!!/Boolean等方法手动进行转换
+ 条件判断中的条件最后都会转化为布尔类型

2.转化规律
只有0 '' NaN undefined null这五个值是false，其余都是true

### 基本类型转引用类型（包装类）

### +号的隐式转化（基于toPrimitive方法的底层机制进行比较）

### ==比较的隐式转化
转化规则：==在进行比较的时候，如果左右两边的数据类型不一样，则先转化为相等的数据类型，然后再进行比较

#### 特殊规则1:对象和对象比较:本质是比较的对象的引用地址是否相等
如果引用地址相等，返回true；否则转化为false

#### 特殊规则2：其他所有类型进行比较，都需要先转化为数字然后进行比较
对象和数字比较：本质是将对象转化为数字类型，然后进行比较
对象和字符串比较：本质是将对象先基于toString转化为字符串，然后和字符串比较。这里不会转化为数字进行比较。
对象和布尔值比较：本质是将对象转化为数字，把布尔值也转化为数字
对象和undefined或者null比较：恒等于false，因为undefiend和null是相等的，除了这个情况之外他们只和自身相等，所以对象和这两者比较一定是false。
字符串和数字比较：本质是将字符串转化为数字(数字优先级高)
字符串和布尔值比较:本质是将两者都转化为数字
布尔值和数字比较:本质是将布尔值转化为数字

####特殊规则3：null和undefiend的情况
undefiend == undefined true
null == null true
undefiend == null true
剩下的所有涉及undefiend或者null的比较都是false

#### 例子
[] == []  false 引用地址不同，基于对象和对象比较
![] == [] true 
![]转化为布尔值是false，false == []是基于对象和布尔值比较，都转化为数字
 0 == 0 结果为true
 
[]==false  都转化为数字 0==0 结果为true
![]==false  先把![]转化为布尔值为false false == false 结果为true



